<template>
  <div class="bg-white rounded-lg p-6 shadow mt-4">
    <div class="pb-6">
      <span class="text-xl font-bold">B√¨nh lu·∫≠n</span>
    </div>
    <!-- New comment -->
    <div class="flex items-start space-x-4 mb-6">
      <img
        v-if="currentUser?.avatar || currentUser?.b64"
        :src="currentUser.avatar || `data:image/png;base64,${currentUser.b64}`"
        class="w-10 h-10 rounded-full object-cover bg-gray-200"
      />
      <div class="relative flex-1">
        <textarea
          v-model="newComment"
          rows="2"
          class="w-full bg-gray-100 rounded-3xl px-6 py-4 pr-12 focus:ring-2 focus:ring-teal-300 resize-none"
          placeholder="Vi·∫øt b√¨nh lu·∫≠n..."
        />

        <button
          @click="handleAddComment"
          class="absolute right-4 bottom-4 focus:outline-none"
        >
          <SendHorizontal class="w-5 h-5 text-blue-500 hover:text-blue-600" />
        </button>
      </div>
    </div>

    <!-- Comments list -->
    <div v-if="comments.length">
      <div
        v-for="comment in comments"
        :key="comment.id"
        class="flex space-x-4 py-3"
      >
        <img
          v-if="comment.userDTO?.avatar || comment.userDTO?.b64"
          :src="
            comment.userDTO.avatar ||
            `data:image/png;base64,${comment.userDTO.b64}`
          "
          class="w-10 h-10 rounded-full object-cover bg-gray-200"
        />
        <div class="flex-1">
          <div class="flex justify-between items-start">
            <div class="flex flex-col items-start space-y-2">
              <div class="] bg-blue-50 rounded-2xl px-3 py-2">
                <span class="font-semibold text-gray-800">
                  {{ comment.userDTO.fullName }}
                </span>
                <span class="block text-gray-700">{{ comment.content }}</span>
              </div>

              <div
                class="flex items-center pl-2 space-x-4 text-xs text-gray-500"
              >
                <span>{{ formatDate(comment.lastUpdate) }}</span>
                <button
                  @click="handleLike(comment)"
                  class="flex items-center space-x-1 hover:text-blue-600"
                >
                  <ThumbsUpIcon
                    :class="[comment.liked ? 'text-blue-600' : 'text-gray-500']"
                    class="w-4 h-4"
                  />
                  <span>{{ comment.rate }}</span>
                </button>
              </div>
            </div>

            <!-- Dropdown menu ch·ªâ hi·ªÉn th·ªã khi comment thu·ªôc v·ªÅ currentUser -->
            <a-dropdown
              v-if="
                currentUser &&
                comment.userDTO &&
                currentUser.id === comment.userDTO.id
              "
              trigger="click"
            >
              <template #overlay>
                <a-menu>
                  <a-menu-item @click="startEditing(comment)">
                    Ch·ªânh s·ª≠a
                  </a-menu-item>
                  <a-menu-item @click="confirmDelete(comment.id)">
                    X√≥a
                  </a-menu-item>
                </a-menu>
              </template>
              <MoreHorizontalIcon
                class="w-5 h-5 text-gray-400 hover:text-gray-600 cursor-pointer"
              />
            </a-dropdown>
          </div>

          <div
            v-if="editingComment && editingComment.id === comment.id"
            class="mt-3 relative"
          >
            <textarea
              v-model="editingComment.content"
              rows="2"
              class="w-full bg-gray-100 rounded-3xl px-6 py-4 pr-12 focus:ring-2 focus:ring-teal-300 resize-none"
            />
            <!-- n√∫t H·ªßy -->
            <button
              @click="cancelEditing"
              class="absolute right-10 bottom-4 focus:outline-none"
            >
              <CircleX class="w-5 h-5 text-red-500 hover:text-red-600" />
            </button>

            <!-- n√∫t L∆∞u -->
            <button
              @click="submitEditing(comment.id)"
              class="absolute right-4 bottom-4 focus:outline-none"
            >
              <SendHorizontal
                class="w-5 h-5 text-blue-500 hover:text-blue-600"
              />
            </button>
          </div>
        </div>
      </div>
      <!-- Pagination -->
      <div class="pt-5 items-center justify-center flex">
        <a-pagination
          size="small"
          :current="pagination.current"
          :pageSize="pagination.pageSize"
          :total="pagination.total"
          @change="handlePageChange"
        />
      </div>
    </div>

    <div v-else class="text-center py-6 text-gray-400">
      Ch∆∞a c√≥ b√¨nh lu·∫≠n n√†o.
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, watch } from "vue";
import { message, Modal, Pagination } from "ant-design-vue";
import viVN from "ant-design-vue/es/locale/vi_VN";
import {
  ThumbsUpIcon,
  MoreHorizontalIcon,
  SendHorizontal,
  CircleX,
} from "lucide-vue-next";
import {
  getListComment,
  createComment,
  updateComment,
  deleteComment,
} from "@/apis/commentService.js";
import { getProfile } from "@/apis/authService.js";
import { useAuthStore } from "@/stores/store";

import dayjs from "dayjs";
import relativeTime from "dayjs/plugin/relativeTime";
import "dayjs/locale/vi";

// Props
const props = defineProps({
  postId: { type: Number, required: true },
});

// Reactive state
const comments = ref([]);
const newComment = ref("");
const editingComment = ref(null);
const currentUser = ref(null);
const likedComments = ref([]);

// Pagination state
const pagination = ref({ current: 1, pageSize: 5, total: 0 });

dayjs.extend(relativeTime);
dayjs.locale("vi");

// Fetch current user
async function fetchProfile() {
  try {
    currentUser.value = (await getProfile()).data;
  } catch (error) {
    console.error("L·ªói khi t·∫£i profile:", error);
  }
}

// Fetch comments with pagination (v·ªõi log)
// Fetch comments with pagination
async function fetchComments() {
  console.log("üåÄ fetchComments called", {
    postId: props.postId,
    page: pagination.value.current,
    pageSize: pagination.value.pageSize,
  });

  const params = {
    postId: props.postId,
    start: pagination.value.current - 1,
    limit: pagination.value.pageSize,
  };
  console.log("‚û°Ô∏è Request params for getListComment:", params);

  try {
    const { data } = await getListComment(params);
    console.log("‚¨ÖÔ∏è API response data:", data);

    // === CH·ªñ S·ª¨A ===
    // tr∆∞·ªõc kia b·∫°n filter theo c.postId n√™n lu√¥n ra 0
    // ƒë√∫ng ra l√† c.idPost, ho·∫∑c b·ªè filter n·∫øu API ƒë√£ ƒë√∫ng
    const filtered = (data.items || []).filter(
      (c) => c.idPost === props.postId
    );
    console.log("üîç Filtered comments count:", filtered.length);

    comments.value = filtered.map((c) => ({
      ...c,
      liked: likedComments.value.includes(c.id),
    }));
    console.log("‚úÖ Mapped comments:", comments.value);

    pagination.value.total = data.total ?? filtered.length;
    console.log("üìä Updated pagination.total:", pagination.value.total);
  } catch (error) {
    message.error("L·ªói t·∫£i b√¨nh lu·∫≠n");
    console.error("‚ùå fetchComments error:", error);
  }
}

// Handle page change (v·ªõi log)
function handlePageChange(page) {
  console.log("‚ÜîÔ∏è handlePageChange: new page =", page);
  pagination.value.current = page;
  fetchComments();
}

// Create comment
async function handleAddComment() {
  console.log("üìù handleAddComment start", { newComment: newComment.value });
  const authStore = useAuthStore();
  console.log("üîë AuthStore:", {
    isAuthenticated: authStore.isAuthenticated,
    token: authStore.token,
  });

  // Ki·ªÉm tra ƒëƒÉng nh·∫≠p
  if (!authStore.isAuthenticated || !authStore.token?.trim()) {
    console.warn("‚ö†Ô∏è Ch∆∞a ƒëƒÉng nh·∫≠p, kh√¥ng th·ªÉ b√¨nh lu·∫≠n");
    return message.warning("B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ b√¨nh lu·∫≠n.");
  }

  // Ki·ªÉm tra n·ªôi dung
  if (!newComment.value.trim()) {
    console.warn("‚ö†Ô∏è newComment tr·ªëng");
    return message.warning("Vui l√≤ng nh·∫≠p n·ªôi dung b√¨nh lu·∫≠n.");
  }

  try {
    console.log("‚è≥ G·ª≠i request createComment...");
    const response = await createComment(
      { content: newComment.value, idPost: props.postId, rate: 0 },
      authStore.token
    );
    console.log("üöÄ createComment response:", response);
    message.success("B√¨nh lu·∫≠n ƒë√£ ƒë∆∞·ª£c ƒëƒÉng");
    newComment.value = "";
    fetchComments();
  } catch (error) {
    console.error("‚ùå handleAddComment error:", error);
    // hi·ªÉn th·ªã th√™m th√¥ng tin l·ªói n·∫øu c·∫ßn
    message.error(
      `L·ªói khi ƒëƒÉng b√¨nh lu·∫≠n${
        error?.response?.data?.message ? ": " + error.response.data.message : ""
      }`
    );
  }
}

// Edit comment
function startEditing(comment) {
  editingComment.value = { ...comment };
}
function cancelEditing() {
  editingComment.value = null;
}
async function submitEditing(id) {
  if (!editingComment.value.content.trim()) {
    return message.warning("N·ªôi dung b√¨nh lu·∫≠n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng");
  }
  try {
    await updateComment(
      {
        id,
        content: editingComment.value.content,
        rate: editingComment.value.rate ?? 0,
      },
      localStorage.getItem("token")
    );
    message.success("C·∫≠p nh·∫≠t b√¨nh lu·∫≠n th√†nh c√¥ng");
    editingComment.value = null;
    fetchComments();
  } catch {
    message.error("L·ªói khi c·∫≠p nh·∫≠t b√¨nh lu·∫≠n");
  }
}

// Delete comment
async function handleDeleteComment(id) {
  try {
    await deleteComment(id);
    message.success("X√≥a b√¨nh lu·∫≠n th√†nh c√¥ng");
    likedComments.value = likedComments.value.filter((cid) => cid !== id);
    fetchComments();
  } catch {
    message.error("L·ªói khi x√≥a b√¨nh lu·∫≠n");
  }
}
function confirmDelete(id) {
  Modal.confirm({
    title: "X√°c nh·∫≠n x√≥a b√¨nh lu·∫≠n?",
    content: "B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a b√¨nh lu·∫≠n n√†y kh√¥ng?",
    okText: "X√≥a",
    okType: "danger",
    cancelText: "H·ªßy",
    onOk: () => handleDeleteComment(id),
  });
}

// Like/unlike
async function handleLike(comment) {
  const authStore = useAuthStore();
  if (!authStore.isAuthenticated || !authStore.token?.trim()) {
    return message.warning("B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ th√≠ch b√¨nh lu·∫≠n.");
  }

  try {
    const newRate = comment.liked ? comment.rate - 1 : comment.rate + 1;
    comment.liked
      ? (likedComments.value = likedComments.value.filter(
          (id) => id !== comment.id
        ))
      : likedComments.value.push(comment.id);
    comment.liked = !comment.liked;

    await updateComment(
      { id: comment.id, content: comment.content, rate: newRate },
      authStore.token
    );

    comment.liked
      ? message.success("ƒê√£ like b√¨nh lu·∫≠n")
      : message.error("B·ªè like b√¨nh lu·∫≠n");

    comment.rate = newRate;
  } catch {
    message.error("L·ªói khi x·ª≠ l√Ω like b√¨nh lu·∫≠n");
  }
}

// Date formatting
function formatDate(dateStr) {
  return dateStr ? dayjs(dateStr).fromNow() : "";
}

// Lifecycle
onMounted(async () => {
  console.log("üöÄ Component mounted, postId =", props.postId);
  const authStore = useAuthStore();
  if (authStore.isAuthenticated && authStore.token?.trim() !== "") {
    console.log("üîë ƒê√£ ƒëƒÉng nh·∫≠p, fetchProfile()");
    await fetchProfile();
  } else {
    console.log("üîì Ch∆∞a ƒëƒÉng nh·∫≠p");
  }
  fetchComments();
});

// Watch postId ƒë·ªÉ reset ph√¢n trang (v·ªõi log)
watch(
  () => props.postId,
  (newId, oldId) => {
    console.log(
      `üîÑ props.postId changed from ${oldId} to ${newId}, reset page ‚Üí 1`
    );
    pagination.value.current = 1;
    fetchComments();
  }
);
</script>
